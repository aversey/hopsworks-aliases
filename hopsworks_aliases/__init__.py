#
#   Copyright 2025 Hopsworks AB
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

"""Scripts for automatic management of aliases."""

import importlib
from pathlib import Path

import gitignorefile
from setuptools import Command, Distribution


SOURCES = [
    "hopsworks/__init__.py",
    "hopsworks/internal",
]
IGNORED = [
    "tests",
    "hsfs",
    "hopsworks",
    "hsml",
    "hopsworks_common",
    "hopsworks.egg-info",
]
GITIGNORE = gitignorefile.parse(".gitignore")
# Everything that is not a top-level file, a part of sources, or a part of ignored is considered to be automatically managed.


def traverse(path, f):
    if not path.exists():
        return
    if path.is_file():
        f(path)
        return
    for child in path.iterdir():
        traverse(child, f)


def collect_imports(root):
    imports = []

    def imports_add(file):
        pkg = file.parent.relative_to(root).as_posix().replace("/", ".")
        if file.name == "__init__.py":
            imports.append(pkg)
        elif file.suffix == ".py":
            imports.append(pkg + "." + file.name[:-3])

    for source in SOURCES:
        traverse(root / source, imports_add)

    return imports


def collect_aliases(root):
    for import_str in collect_imports(root):
        importlib.import_module(import_str, package=".")
    aliases = importlib.import_module("hopsworks.internal.aliases", package=".")
    return aliases.Registry.get_modules()


def collect_managed(root):
    managed = {}
    for pkg, imports in collect_aliases(root).items():
        pkg = root / pkg.replace(".", "/") / "__init__.py"
        managed[pkg] = (
            "# ruff: noqa\n"
            "# This file is generated by aliases.py. Do not edit it manually!\n"
        )
        if not imports:
            continue
        managed[pkg] += "import hopsworks.internal.aliases\n"
        imports.sort()  # this is needed for determinism
        imported_modules = {"hopsworks.internal.aliases"}
        declared_names = set()
        for f, i, im in imports:
            original = f"{f}.{i}"
            alias = im.as_alias if im.as_alias else i
            if alias in declared_names:
                print(
                    f"Error: {original} is attempted to be exported as {alias} in {pkg}, "
                    "but the package already contains this alias."
                )
                exit(1)
            if f not in imported_modules:
                managed[pkg] += f"import {f}\n"
                imported_modules.add(f)
            if im.deprecated_by:
                db = list(im.deprecated_by)
                db.sort()  # this is needed for determinism
                deprecated_by = ", ".join(f'"{s}"' for s in db)
                available_until = ""
                if im.available_until:
                    available_until = f', available_until="{im.available_until}"'
                original = f"hopsworks.internal.aliases.deprecated({deprecated_by}{available_until})({original})"
            managed[pkg] += f"{alias} = {original}\n"
    return managed


def generate_aliases(source_root, destination_root):
    managed = collect_managed(source_root)
    for filepath, content in managed.items():
        filepath: Path
        filepath = destination_root / filepath.relative_to(source_root)
        filepath.parent.mkdir(parents=True, exist_ok=True)
        filepath.touch()
        filepath.write_text(content)


class build_aliases(Command):
    def initialize_options(self) -> None:
        self.build_temp: str | None = None
        self.aliases_dir: Path | None = None

    def finalize_options(self) -> None:
        self.set_undefined_options("build", ("build_temp", "build_temp"))
        assert self.build_temp is not None
        self.aliases_dir = Path(self.build_temp) / "aliases"

    def run(self) -> None:
        print("Building aliases...")
        assert self.aliases_dir is not None

        generate_aliases(Path(), self.aliases_dir)


class install_aliases(Command):
    def initialize_options(self) -> None:
        pass

    def finalize_options(self) -> None:
        pass

    def run(self) -> None:
        print("Installing aliases...")


def finalize_distribution_options(dist: Distribution) -> None:
    dist.get_command_class("build").sub_commands.append(
        (build_aliases.__name__, None),
    )
    dist.get_command_class("install").sub_commands.append(
        (install_aliases.__name__, None),
    )
